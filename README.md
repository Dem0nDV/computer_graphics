# MMCS_332
# MODULE1: 2D графика.
## Lab1: Работа в графическом режиме
### Task1: Построение графика функции.
Задаются: диапазон значений, функция, необходимо построить график с возможностью масштабирования – в максимальных и минимальных точках график касается верхних и нижних границ графического окна. Обязательный тест – sin(x) и x^2.
Необходимо предусмотреть выбор функций из некоторого списка. В функцию построения графика функцию передавать как параметр.
Не использовать стандартные функции построения графиков.
## Lab2: Цветовые пространства. Преобразование цветовых пространств.
### Task1: 
Преобразовать изображение из RGB в оттенки серого. Реализовать два варианта формулы с учетом разных вкладов R, G и B в интенсивность (см презентацию). Затем найти разность полученных полутоновых изображений. Построить гистограммы интенсивности после одного и второго преобразования.
### Task2:
Выделить из полноцветного изображения один из каналов R, G, B  и вывести результат. Построить гистограмму по цветам.
### Task3:
Преобразовать изображение из RGB в HSV. Добавить возможность изменять значения оттенка, насыщенности и яркости. Результат сохранять в файл, предварительно преобразовав обратно.
## Lab3: Растровые алгоритмы.
### Task1: Рекурсивный алгоритм заливки на основе серий пикселов (линий).
1a) Заливка заданным цветом.

1b) Заливка рисунком из графического файла. Файл можно загрузить встроенными средствами и затем считывать точки изображения для использования в заливке.
### Task2: Выделение границы связной области.
На вход подается изображение. Граница связной области задается одним цветом. Имея начальную точку границы организовать ее обход, занося точки в список в порядке обхода.
Начальную точку границы можно получать любым способом. Для контроля полученную границу прорисовать поверх исходного изображения.
## Lab4: Аффинные преобразования на плоскости и вспомогательные алгоритмы.
В программе должны присутствовать следующие примитивы: точка, ребро (отрезок), полигон (мин требование - квадрат). Они рисуются мышкой.

Программа должна содержать следующие возможности:
* Задать текущий примитив.
* Очистить сцену.
* Применение аффинных преобразований к полигону: смещение, поворот вокруг произвольной точки (задается пользователем мышкой) и вокруг своего центра, масштабирование относительно произвольной точки (задается пользователем мышкой) и относительно своего центра. Все преобразования должны быть реализованы матрицами!
* Поворот ребра на 90 градусов вокруг своего центра.
* Поиск точки пересечения двух ребер (добавление второго ребра мышкой, динамически).

Программа должна позволять выполнить следующие проверки:
* Принадлежит ли точка выпуклому многоугольнику (задание точки мышкой).
* Принадлежит ли точка невыпуклому многоугольнику (задание точки мышкой).
* Классифицировать положение точки относительно ребра (задание точки мышкой).
## Individual1: Пересечение выпуклых полигонов.
## Lab5: L-системы. Diamond-square. Cплайны.
### Task1: L-системы.
Реализовать программу для построения фрактальных узоров посредством L-систем.
Описание L-систем задается в текстовом файле вида:
```
<атомарный символ> <угол поворота> <начальное направление> 
<правило №1>
<правило №2>
...
```
Реализовать возможность разветвления в системе (скобки).
Предусмотреть масштабирование получаемого набора точек (должен помещаться в окне).
### Task2: Diamond-square.
Реализовать алгоритм [midpoint displacement](https://habr.com/ru/post/111538/) для визуализации горного массива.
Необходимо отображать результаты последовательных шагов алгоритма. Программа должна позволять изменять параметры построения ломаной.
### Task3: Кубические сплайны Безье.
Реализовать программу для визуализации составной кубической кривой Безье. 
Программа должна позволять добавлять, удалять  и перемещать опорные точки. 
# MODULE2: Моделирование и визуализация трехмерных объектов. Алгоритмы трассировки лучей для получения реалистических изображений.
## Lab6: Аффинные преобразования в пространстве. Проецирование.
В программе должны присутствовать следующие классы: точка, прямая (ребро), многоугольник (грань), многогранник.
Программа должна содержать следующие возможности:
* Отображение одного из правильных многогранников: тетраэдр, гексаэдр, октаэдр, икосаэдр*, додекаэдр*.
* Применение аффинных преобразований: смещение, поворот, масштаб, с указанием параметров преобразования. Преобразования должны быть реализованы матрицами!
* Отражение относительно выбранной координатной плоскости.
* Масштабирование многогранника относительно своего центра.
* Вращение многогранника вокруг прямой проходящей через центр многогранника, параллельно выбранной координатной оси.
* Поворот вокруг произвольной (заданной координатами двух точек) прямой на заданный угол.

Программа должна позволять отобразить сцену в одной из заданных проекций (преобразования должны быть реализованы матрицами):
* перспективной;
* изометрической;
* ортографической (на выбранную координатную плоскость).

## Lab7: Построение трёхмерных моделей.
### Task1: Загрузка и сохранение модели многогранника из файла.
Формат модели должен содержать данные о гранях. Формат файла выбирается программистом.
Необходимо отобразить загруженную модель, позволить применять к ней аффинные преобразования. 
Для тестов можно использовать модели многогранников из Лаб. №6.
### Task2: Построение фигуры вращения.
Фигура вращения задаётся тремя параметрами: образующей (набор точек), осью вращения и количеством разбиений. Угол вращений можно вычислить, поделив 360° на количество разбиений.
Программа должна давать возможность задать образующую и построить фигуру вращения относительно выбранной координатной оси с заданным количеством разбиений. Формат модели должен содержать данные о гранях.
Сохранить полученную модель в файл.
Необходимо загрузить и отобразить полученную модель, применить к ней аффинные преобразования.
### Task3: Построение графика двух переменных.
Сегмент поверхности задаётся функцией f(x, y) = z, диапазонами отсечения [x0, x1], [y0, y1] и количеством разбиений по осям (шагом).
Программа должна позволять строить сегмент поверхности, заданный выбранной функцией на заданном диапазоне с заданным количеством разбиений. Формат модели должен содержать данные о гранях. Диапазоны и разбиения можно задавать идентичными для X и Y.
Необходимо отобразить полученную модель, позволить применять к ней аффинные преобразования.
Загрузить и Сохранить полученную модель в файл.
## Lab8: Отсечение нелицевых граней.
### Task1: Отсечение нелицевых граней.
Изобразить вращающийся объект (созданный ранее) с отсечением нелицевых граней:
* Добавить к каждой грани вектор нормали, направленный вовне, относительно объекта. Вектор нормали вычисляется, как векторное произведение векторов, лежащих в плоскости грани.
* Задать вектор обзора. Добавить возможность его изменения.
* Реализовать отсечение нелицевых граней с учетом вектора нормали и направления обзора.
### Task2: Алгоритм Z-буфера.
Реализовать алгоритм z-буфера для удаления невидимых граней. Направление обзора может быть фиксированным.
* Добавить возможность применять преобразования к отображаемому объекту.
* Если объект выпуклый, то необходимо добавить еще несколько объектов для демонстрации корректной работы алгоритма в случае перекрытия.
### Task3: Камера.
Добавить объект-камеру. 
* Камера задается своим положением, направлением обзора и матрицей проекционного преобразования. 
* Получить изображение с камеры, вращая её вокруг статического объекта. 
## Lab9: Освещение и текстурирование.
### Task1: Освещение.
Реализовать метод Гуро для затенения фигур.
* Добавить нормаль к каждой вершине.
* Добавить положение источника света и цвет объекта.
* Вычислить цвет в каждой вершине по модели Ламберта (рассеяную часть).
* Закрасить грань, интерполируя цвет между цветами вершин (билинейная интерполяция).
* Добавить возможность применения преобразований к объекту.
### Task2: Текстурирование.
Реализовать алгоритм наложения текстуры на полигон. С отсечением невидимых граней.
* Добавить координаты текстуры к каждой вершине.
* При отрисовке грани интерполировать координаты текстуры между координатами вершин.
* Продемонстрировать текстурирование на правильных многогранниках (тетраэдр, куб, октаэдр).
* Добавить возможность применения преобразований к объекту.
### Task3: Метод плавающего горизонта.
* Построить проекцию графика функции 2-х переменных: по алгоритму плавающего горизонта.
* Реализовать отображение линиями.
* Добавить возможность менять направление обзора.
## Individual2: Корнуэльская комната.
Создать сцену: Корнуэльская комната обязательно в виде большого куба. Внутри как минимум 1 объект (не прозрачный и не отражающий). На выбор куб или шар. Один точечный источник света. - 4 балла
* За 2-й объект того же вида + 1 балл.
* За дополнительный объект другого вида ( шар и куб) ещё + 2 балла.
* Добавление зеркального отражения для объекта + 2 балла (по 1-му за каждый тип объекта). С возможностью включать и выключать зеркальность.
* Добавление прозрачности + 2 балла (по 1-му за каждый тип объекта). С возможностью включать и выключать прозрачность.
* Стена комнаты зеркальная с возможностью выбора стены +1 балл.
* Добавление дополнительного источника света + 1 балл.
Все баллы выше 9 идут в бонусные баллы к экзамену.
# MODULE3: OpenGL.
## Lab10: Введение в OpenGL.
### Task1: Реализовывать вывод 2D-объектов в экранных координатах.
* Создать окно и вывести стандартный геометрический примитив.
* Рисование произвольных фигур: вывести треугольник, четырехугольник, треугольник окрашенный в различные цвета.
* Обработка ввода: выводить новый примитив произвольного цвета по клику мышки в окне; реализовать управление вращением фигуры с клавиатуры.
### Task2: Реализовать вывод 3D-объектов. Реализовать переключение (с клавиатуры) между перспективной и ортографической проекциями.
Создать пьедестал почёта из кубиков. Сместить его из центра сцены.
Первое место окрасить в золотой цвет, второе - в серебряный, третий - в бронзу.
Реализовать варианты вращения:
* весь пьедестал вокруг центра сцены;
* все кубики вокруг центра пьедестала почета;
* каждый кубик вокруг своей оси.
### Task3: Реализовать вывод 3D-объектов. Реализовать переключение (с клавиатуры) между перспективной и ортографической проекциями.
* Создать елочку из 3-х зеленых конусов (разных размеров) и коричневого цилиндра. Сместить его из центра сцены.
* Создать аллею из таких елочек разных размеров. Модель елочки должна быть одна, а нарисовано много.
## Lab11: Видовые преобразования. Материалы и освещение.
Вывод реализовывать средствами OpenGL, используя мировые координаты. Все объекты реализовать из готовых примитивов.
1. Сцена в виде площади: плоскость с текстурой типа брусчатки. 
2. На ней стоят фонари (из цилиндров можно сделать). 
Фонари (точечные источники света) включаются и выключаются по нажатию клавиш.
3. По сцене перемещается грузовая машина (из кубиков, колеса - торы, фары - шарики). 
Машина с наложенными текстурами. Фары (источники света - прожекторы) включаются и выключаются по нажатию клавиш. Машина управляется с клавиатуры или мышью.
4. Реализовать вращение камеры вокруг сцены. На камере источник света - прожектор.

Для большей наглядности работы освещения в OpenGL, плоскости нужно делать не четырьмя вершинами, а рисовать сеткой nxn! Это касается и кубиков.
## Lab12: Шейдеры. Введение.
### Task1: Вершинный шейдер.
Использовать единственный файл шейдера (информация хранится в отдельном файле). Матрицы преобразований  передаются из программы. Использовать перспективную проекцию.
* Масштабирование на заданные коэффициенты вдоль осей X и Y. 
* Поворот вокруг задаваемой оси на задаваемый угол.
### Task2: Фрагментный шейдер.
Использовать несколько файлов шейдеров. Отобразить два объекта с разными фрагментными шейдерами.
* Сплошная одноцветная заливка (цвет передается).
* Заливка штриховкой: горизонтальная, вертикальная (цвета и ширина полос передаются).
### Task3: Фрагментный шейдер - наложение текстуры.
* Наложить 1 текстуру.
* Смешать текстуру с цветом.
* Наложить 2 текстуры. Коэффициент смешивания передается из главной программы.
